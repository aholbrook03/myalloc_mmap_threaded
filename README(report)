Info on the threaded version of malloc is below ("Threaded malloc using mmap").

This file includes an explanation of how my malloc (mymalloc) implementation
works. Also, I've included the PDF that I had included when I did this program
in the Fall of 2009 -- the benchmark results would not be different since the
method is the same.

The bench.c file (and the corresponding bench executable generated by make)
performs a stress test by allocating and random number of bytes (between 1 and
MAX_ALLOC) 10000 (configurable by changing NUM_ALLOC) times.

My Method:

The heap memory is partitioned into "blocks." Each block is either free or used,
meaning that is either availble to be allocated to the user or already allocated,
respectively. As the user requests memory (calls malloc), the free blocks list
is traversed as each block's size is checked against the size requested by the
user. When a block is found that is greater than or equal to the requested size,
it is possibly split, creating two blocks: one the user's requested size and two
the rest.

Stress Test (bench.c):

I've already explained the stress test, but it is successful if it doesn't
result in a "Segmentation fault."

-------------------------------------------------------------
Threaded malloc using mmap

Both tests were performed by allocating from 1 to 1MB from 1 to 10000 times (per
thread).

standard malloc (100 threads):
7.850000 seconds
6.190000 seconds
6.720000 seconds
5.630000 seconds
6.290000 seconds
7.490000 seconds
6.130000 seconds
7.580000 seconds
5.440000 seconds
5.760000 seconds

my malloc (100 threads):
6.790000 seconds
6.680000 seconds
6.370000 seconds
6.780000 seconds
7.000000 seconds
6.650000 seconds
6.780000 seconds
6.280000 seconds
6.850000 seconds
6.630000 seconds

standard malloc (300 threads):
16.350000 seconds
17.210000 seconds
...

my malloc (300 threads):
5.140000 seconds
5.390000 seconds
5.030000 seconds
5.240000 seconds
4.030000 seconds
5.030000 seconds
5.090000 seconds
4.160000 seconds
4.860000 seconds
5.910000 seconds
4.980000 seconds

(Results are from bench.c)

From these results, it seems that the standard version of malloc on my machine
(Linux 2.6.32) is much slower than my threaded, mmap version when using many
threads.

My Design:
The design is very similar to my single-threaded version, except for the
addition of a thread table and using mmap instead of sbrk to allocate new pages.
There is a limit to the number of threads that can request memory, and this is
due to the size of my thread table, which is 4KB. (The thread limit is ~300.)
The thread table records the used and free lists for each thread. When a new
thread asks for memory, the table must be modified (requiring a lock). Other
than modifying the table, however, locking never needs to be performed.

